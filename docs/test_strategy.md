# テスト戦略

このプロジェクトでは、テストを読みやすく、意図が伝わりやすい形で保守するために以下の指針を採用します。

## Arrange-Act-Assert (AAA) パターン
- すべてのテストを Arrange（準備）→ Act（実行）→ Assert（検証）の3段階で記述する。
- Arrange では、必要なモックの設定やテスト対象（System Under Test）の初期化を行う。
- Act では、検証したい操作を1回だけ呼び出すことを意識する。
- Assert では、戻り値や副作用を明確に検証する。暗黙的に失敗するケースに頼らない。
- フェーズの境界が分かるように空行や `# Arrange` などのコメントを活用する。

## 非同期処理のテスト
- 非同期関数をテストする場合は `pytest.mark.anyio("asyncio")` を付与してイベントループを提供する。
- リポジトリやサービスをモック化する際は、`AsyncMock` もしくは `return_value` に await 可能なオブジェクトを設定する。
- トランザクションなど複数テストで共通する非同期コンテキストはフィクスチャとして切り出し、重複や記述ミスを抑える。

## テストダブルとフィクスチャ
- ドメイン依存 (Repository/Service) はモックに差し替え、ビジネスロジックに焦点をあてる。
- 共有で使うスタブやノウハウはフィクスチャ化し、個々のテストでは差分だけを記述するようにする。
- インフラ実装に依存しないようドメインインターフェース越しに操作する。

## テストを書くタイミング
- UseCase、ドメインサービス、例外ハンドラなど、ビジネスロジックが分岐する箇所にはユニットテストを用意する。
- テスト名は意図が伝わる形（例: `test_create_user_failure_username_already_exists`）。
- 複数レイヤーを跨ぐ動作を確認したい場合は、同じ AAA パターンを用いて統合テストを追加する。

これらのルールによって、テストの読みやすさと変更時の安心感を両立させます。
